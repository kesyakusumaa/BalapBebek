<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Duck River Race — 15s Final</title>
<style>
  :root{
    --bg:#0b1d3a; --panel:#101826; --accent:#ffd166; --text:#eaf2ff;
    --grass1:#2e7d32; --grass2:#1b5e20; --muted:#c9d7ff;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{max-width:1100px;margin:auto;padding:20px;display:flex;flex-direction:column;gap:14px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  h1{font-size:clamp(22px,3vw,32px);margin:0;letter-spacing:.5px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{
    background:var(--accent);color:#1b1b1b;border:none;padding:10px 14px;border-radius:10px;
    font-weight:700;cursor:pointer;box-shadow:0 4px 0 #caa94f;transition:transform .1s,opacity .2s;
  }
  button:hover{transform:translateY(-1px)}
  button.secondary{background:#2b3750;color:#dbe8ff;box-shadow:none;border:1px solid #3d4a66}
  button.ghost{background:transparent;border:1px solid #3d4a66;color:#dbe8ff}
  button:disabled{opacity:.45;cursor:not-allowed;transform:none}
  .board{
    background:var(--panel);border:1px solid #2a3550;border-radius:14px;padding:12px 14px;
    display:flex;align-items:center;gap:18px;flex-wrap:wrap
  }
  .stat{opacity:.9}
  .banner{text-align:center;font-weight:800;letter-spacing:.5px}
  .winner{color:#00e58f}
  canvas{
    width:100%;height:auto;display:block;border-radius:14px;border:1px solid #203356;
    box-shadow:0 10px 24px rgba(0,0,0,.35)
  }
  /* Countdown Overlay */
  .overlay{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;
    background:rgba(0,0,0,.35); /* transparan agar bebek terlihat */
    backdrop-filter:blur(2px);z-index:5;pointer-events:none;
  }
  .overlay.show{display:flex}
  .count{
    font-size:clamp(42px,8vw,108px);font-weight:900;letter-spacing:2px;
    padding:10px 24px;border-radius:16px;background:rgba(16,24,38,.85);
    border:1px solid #2a3550;box-shadow:0 12px 30px rgba(0,0,0,.4)
  }
  /* History Modal */
  .modal{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;
    background:rgba(0,0,0,.55);backdrop-filter:blur(3px);z-index:6;
  }
  .modal.show{display:flex}
  .card{
    width:min(960px,95vw);max-height:80vh;overflow:auto;background:#0f1726;border:1px solid #2a3550;
    border-radius:16px;box-shadow:0 18px 40px rgba(0,0,0,.5);padding:10px 14px 16px;
  }
  .card h2{margin:8px 0 10px;font-size:clamp(20px,2.6vw,28px)}
  .card .row{display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .card table{width:100%;border-collapse:collapse;font-size:14px}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid #2a3550;border-radius:999px;background:#142039;color:var(--muted);font-weight:600;margin:4px 6px 0 0}
  .dot{width:12px;height:12px;border-radius:50%}
  details{background:#0e1a33;border:1px solid #24365b;border-radius:10px;padding:8px 10px;margin:8px 0}
  details summary{cursor:pointer;font-weight:700;color:#dbe8ff}
  .small{opacity:.8;font-size:12px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Duck River Race</h1>
      <div class="controls">
        <button id="startBtn">Start Race</button>
        <button id="pauseBtn" class="secondary" disabled>Pause</button>
        <button id="resetBtn" class="secondary" disabled>Reset</button>
        <button id="historyBtn" class="ghost">History</button>
      </div>
    </header>

    <div class="board">
      <div class="stat">Durasi balapan: <b>15 detik</b>. Tekan <b>Start Race</b> untuk mulai. Pertama ke finish menang; jika 15s habis, peringkat diambil dari posisi terdepan.</div>
      <div id="status" class="banner">Ready…</div>
    </div>

    <canvas id="race" width="1200" height="700" aria-label="Duck racing river canvas"></canvas>
  </div>

  <!-- Countdown overlay -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div id="count" class="count">3</div>
  </div>

  <!-- History modal -->
  <div id="historyModal" class="modal" aria-hidden="true">
    <div class="card">
      <div class="row">
        <h2>Race History</h2>
        <div class="controls">
          <button id="clearHistoryBtn" class="secondary">Clear History</button>
          <button id="closeHistoryBtn" class="secondary">Close</button>
        </div>
      </div>
      <div id="historyBody"></div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('race');
  const ctx = canvas.getContext('2d');

  // Controls & UI
  const statusEl   = document.getElementById('status');
  const startBtn   = document.getElementById('startBtn');
  const pauseBtn   = document.getElementById('pauseBtn');
  const resetBtn   = document.getElementById('resetBtn');
  const historyBtn = document.getElementById('historyBtn');

  const overlay = document.getElementById('overlay');
  const countEl = document.getElementById('count');

  const historyModal    = document.getElementById('historyModal');
  const closeHistoryBtn = document.getElementById('closeHistoryBtn');
  const clearHistoryBtn = document.getElementById('clearHistoryBtn');
  const historyBody     = document.getElementById('historyBody');

  // Hi-DPI scaling
  let scale = 1;
  function fitHiDPI() {
    const ratio = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const cssW = canvas.clientWidth;
    const cssH = Math.round(cssW * (canvas.height / canvas.width));
    canvas.style.height = cssH + 'px';
    canvas.width = cssW * ratio;
    canvas.height = cssH * ratio;
    scale = ratio;
  }
  fitHiDPI();
  window.addEventListener('resize', () => {
    fitHiDPI();
    generateScenery();
    draw();
  });

  // Settings
  const RACE_LIMIT = 15; // <<< durasi balapan (detik)
  const DUCK_COUNT = 10;
  const margin = 60;
  const finishOffset = 110;
  const riverPadding = 20;

  const colors = [
    '#e74c3c','#3498db','#2ecc71','#f39c12','#9b59b6',
    '#16a085','#f1c40f','#e84393','#8e6e53','#1abc9c'
  ];

  // State
  const ducks = [];
  let running = false;    // true after GO
  let paused = false;
  let winner = null;
  let lastTime = 0;
  let countingDown = false;

  // Ranking bookkeeping
  let finishOrder = [];          // array of duck ids by finishing rank
  let finishTimes = {};          // map: id -> seconds
  let raceIndex = Number(localStorage.getItem('duck_race_lastIndex') || 0);
  let history = [];
  try { history = JSON.parse(localStorage.getItem('duck_race_history_v1') || '[]'); } catch(_) { history = []; }

  // Scenery
  let trees = [], rocks = [];

  function rand(min,max){ return Math.random()*(max-min)+min; }
  function pseudoNoise(t){ return Math.sin(t*1.3)*0.6 + Math.sin(t*0.7+2.13)*0.4; }

  function resetRace() {
    ducks.length = 0;
    winner = null;
    running = false;
    paused = false;
    countingDown = false;
    finishOrder = [];
    finishTimes = {};
    lastTime = performance.now();

    // buttons state
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resetBtn.disabled = true;
    pauseBtn.textContent = 'Pause';
    statusEl.textContent = 'Ready…';

    const W = canvas.width / scale;
    const H = canvas.height / scale;
    const riverTop = margin;
    const riverBot = H - margin;
    const riverH = riverBot - riverTop;
    const laneH = riverH / DUCK_COUNT;

    for (let i=0;i<DUCK_COUNT;i++){
      const y = riverTop + laneH*(i+0.5);
      const base = rand(90,120);
      const jitter = rand(20,40);
      ducks.push({
        id: i+1,
        color: colors[i%colors.length],
        x: margin + 10,
        y,
        baseSpeed: base,
        jitter: jitter,
        noiseT: Math.random()*1000
      });
    }
    generateScenery();
    draw(); // gambar dulu agar terlihat
  }

  function generateScenery(){
    const W = canvas.width / scale;
    const H = canvas.height / scale;

    const usableLeft = riverPadding + 20;
    const usableRight = W - riverPadding - 40;
    const bankTopYMin = 18, bankTopYMax = Math.max(22, margin - 12);
    const bankBotYMin = H - margin + 12, bankBotYMax = H - 18;

    trees = []; rocks = [];
    for (let i=0;i<10;i++){
      trees.push({ x: rand(usableLeft, usableRight), y: rand(bankTopYMin, bankTopYMax), s: rand(0.8,1.2) });
      trees.push({ x: rand(usableLeft, usableRight), y: rand(bankBotYMin, bankBotYMax), s: rand(0.8,1.2) });
    }
    for (let i=0;i<8;i++){
      rocks.push({ x: rand(usableLeft, usableRight), y: rand(bankTopYMin, bankTopYMax), s: rand(0.7,1.3) });
      rocks.push({ x: rand(usableLeft, usableRight), y: rand(bankBotYMin, bankBotYMax), s: rand(0.7,1.3) });
    }
  }

  // Drawing helpers
  function drawBanks(){
    const W = canvas.width / scale;
    const H = canvas.height / scale;

    const gTop = ctx.createLinearGradient(0, 0, 0, margin);
    gTop.addColorStop(0, 'var(--grass1)'); gTop.addColorStop(1, 'var(--grass2)');
    ctx.fillStyle = gTop; ctx.fillRect(0, 0, W, margin);

    const gTopLight = ctx.createLinearGradient(0, 0, 0, margin);
    gTopLight.addColorStop(0, 'rgba(255,255,255,0.05)');
    gTopLight.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gTopLight; ctx.fillRect(0, 0, W, margin);

    const gBot = ctx.createLinearGradient(0, H-margin, 0, H);
    gBot.addColorStop(0, 'var(--grass2)'); gBot.addColorStop(1, 'var(--grass1)');
    ctx.fillStyle = gBot; ctx.fillRect(0, H-margin, W, margin);
  }
  function drawTree(x,y,s=1){
    ctx.save(); ctx.translate(x,y); ctx.scale(s,s);
    ctx.fillStyle = '#7b4f2f'; ctx.fillRect(-6,-8,12,18);
    ctx.fillStyle = '#2ecc71';
    ctx.beginPath(); ctx.arc(0,-22,16,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(-12,-16,14,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(12,-16,14,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.beginPath(); ctx.arc(-4,-24,8,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawRock(x,y,s=1){
    ctx.save(); ctx.translate(x,y); ctx.scale(s,s);
    ctx.beginPath(); ctx.ellipse(0,0,18,12,0,0,Math.PI*2);
    const g = ctx.createRadialGradient(-6,-4,1,0,0,20);
    g.addColorStop(0, '#c9d1d9'); g.addColorStop(1, '#6b7b8a'); ctx.fillStyle = g; ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.ellipse(0,9,20,6,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawScenery(){ for (const t of trees) drawTree(t.x,t.y,t.s); for (const r of rocks) drawRock(r.x,r.y,r.s); }
  function drawRiverBase(){
    const W = canvas.width / scale, H = canvas.height / scale;
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#0b3a63'); g.addColorStop(1,'#0c5f8e');
    ctx.fillStyle = g; ctx.fillRect(riverPadding, margin, W - riverPadding*2, H - margin*2);
    ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 3;
    ctx.strokeRect(riverPadding, margin, W - riverPadding*2, H - margin*2);
  }
  function drawWaves(t){
    const W = canvas.width / scale, H = canvas.height / scale;
    const x0 = riverPadding, x1 = W - riverPadding;
    const y0 = margin, y1 = H - margin, waterH = y1 - y0;
    for (let i=0;i<6;i++){
      const y = y0 + (i+0.5)/6 * waterH;
      ctx.beginPath();
      for (let x=x0;x<=x1;x+=8){
        const k = 0.025 + i*0.002, amp = 3 + i*0.5;
        const yWave = y + Math.sin(x*k + t*0.9 + i)*amp;
        if (x===x0) ctx.moveTo(x,yWave); else ctx.lineTo(x,yWave);
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1.5; ctx.stroke();
    }
    for (let i=0;i<10;i++){
      const y = y0 + (i+0.3)/10 * waterH;
      ctx.beginPath();
      for (let x=x0;x<=x1;x+=10){
        const k = 0.05 + i*0.003, amp = 1.5 + (i%3)*0.4;
        const yWave = y + Math.sin((x*k) - t*1.3 + i*0.7)*amp;
        if (x===x0) ctx.moveTo(x,yWave); else ctx.lineTo(x,yWave);
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1; ctx.stroke();
    }
  }
  function drawLanesAndFinish(){
    const W = canvas.width / scale, H = canvas.height / scale;
    const laneH = (H - margin*2) / DUCK_COUNT;
    ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    for (let i=1;i<DUCK_COUNT;i++){
      const y = margin + laneH*i;
      ctx.beginPath(); ctx.moveTo(riverPadding,y); ctx.lineTo(W-riverPadding,y); ctx.stroke();
    }
    const finishX = W - finishOffset;
    for (let y=margin; y<H-margin; y+=12){
      ctx.fillStyle = (Math.floor(y/12)%2===0) ? 'rgba(255,255,255,0.95)' : 'rgba(0,0,0,0.65)';
      ctx.fillRect(finishX, y, 12, 8);
    }
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fillRect(finishX-3, margin, 3, H-margin*2);
  }
  function roundRect(x,y,w,h,r,fill){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    if (fill) ctx.fill();
  }
  function drawDuck(d, t){
    const bodyL=80, bodyH=32, headR=16;
    const bob = Math.sin(t*2 + d.id)*2;
    ctx.save(); ctx.translate(d.x, d.y + bob);
    ctx.beginPath(); ctx.ellipse(-20, bodyH/2 + 8, 22, 6, 0, 0, Math.PI*2);
    ctx.fillStyle='rgba(255,255,255,0.12)'; ctx.fill();
    ctx.fillStyle = d.color; roundRect(-bodyL/2, -bodyH/2, bodyL, bodyH, 14, true);
    ctx.beginPath(); ctx.arc(bodyL/2 - 12, -bodyH/2 + headR - 4, headR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath();
    const bx = bodyL/2 + 2, by = -bodyH/2 + headR - 4;
    ctx.moveTo(bx, by); ctx.lineTo(bx+16, by-6); ctx.lineTo(bx+16, by+6); ctx.closePath();
    ctx.fillStyle='#ffb703'; ctx.fill();
    ctx.beginPath(); ctx.arc(bodyL/2 - 4, -bodyH/2 + headR - 10, 3.5, 0, Math.PI*2);
    ctx.fillStyle='#101010'; ctx.fill();
    ctx.beginPath(); ctx.ellipse(0,0,18,18,0,0,Math.PI*2);
    ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fill();
    ctx.font='bold 16px system-ui,Segoe UI,Roboto'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillStyle='#fff'; ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=3;
    ctx.strokeText(String(d.id),0,0); ctx.fillText(String(d.id),0,0);
    ctx.restore();
  }

  // Race timing
  const startClock = { t0:0, now:0 };
  function raceTime(){ return (startClock.now - startClock.t0)/1000; }

  // Update movement + early finish
  function update(dt){
    if (!running || paused) return;

    const W = canvas.width / scale;
    const finishX = W - finishOffset;

    for (const d of ducks){
      if (finishTimes[d.id] !== undefined) continue; // already finished

      d.noiseT += dt*0.0015;
      const n = pseudoNoise(d.noiseT);
      const pxPerSec = d.baseSpeed + n*d.jitter;
      const dx = Math.max(30, pxPerSec) * dt;
      d.x += dx/1000;

      // Cek finish garis
      const front = d.x + 80/2;
      if (front >= finishX){
        const t = raceTime();
        finishTimes[d.id] = t;
        finishOrder.push(d.id);

        if (!winner){
          winner = d;
          statusEl.innerHTML = `<span class="winner">Duck #${d.id}</span> takes the lead!`;
        }
        // semua selesai
        if (finishOrder.length === DUCK_COUNT){
          finalizeByOrder(finishOrder.slice(), finishTimes, `Duck #${finishOrder[0]} wins!`);
          return;
        }
      }
    }
  }

  // Finalisasi ketika 15 detik HABIS: urutkan sisa bebek dari posisi terdepan
  function timeUpFinalize(){
    // Gabungkan: yang sudah finish urutan awal, sisanya berdasarkan x desc
    const finishedSet = new Set(finishOrder);
    const pending = ducks
      .filter(d => !finishedSet.has(d.id))
      .sort((a,b) => b.x - a.x)
      .map(d => d.id);

    const order = finishOrder.concat(pending);

    // Waktu: yang sudah finish pakai waktu finish, sisanya = RACE_LIMIT
    for (const id of pending){ finishTimes[id] = RACE_LIMIT; }

    const msg = `Time's up! Duck #${order[0]} leads at 15.00s.`;
    finalizeByOrder(order, finishTimes, msg);
  }

  // Simpan history + update UI
  function finalizeByOrder(order, times, message){
    running = false; paused = false;

    const record = {
      id: ++raceIndex,
      ts: Date.now(),
      order: order.slice(),
      times: times,
      winner: order[0] || null,
      limit: RACE_LIMIT
    };
    history.unshift(record);
    history = history.slice(0, 50);
    localStorage.setItem('duck_race_history_v1', JSON.stringify(history));
    localStorage.setItem('duck_race_lastIndex', String(raceIndex));

    statusEl.innerHTML = `<span class="winner">${message}</span> Race #${record.id} saved.`;
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resetBtn.disabled = false;
  }

  // Draw & loop
  function draw(){
    ctx.setTransform(scale,0,0,scale,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    drawBanks(); drawScenery(); drawRiverBase(); drawWaves(performance.now()/1000); drawLanesAndFinish();

    const t = performance.now()/1000;
    for (const d of ducks) drawDuck(d,t);
  }

  function loop(ts){
    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime; lastTime = ts;

    if (running && !paused){
      startClock.now = ts;
      const elapsed = raceTime();
      // update gerak
      update(dt);
      // update status waktu
      statusEl.textContent = `Racing… ${Math.min(elapsed, RACE_LIMIT).toFixed(1)}/${RACE_LIMIT}s`;
      // habis waktu?
      if (elapsed >= RACE_LIMIT && !winner){
        timeUpFinalize();
      }
    }
    draw();
    requestAnimationFrame(loop);
  }

  // Countdown
  let countdownTimer = null;
  function startCountdown(){
    if (countingDown || running) return;
    countingDown = true;

    // Pastikan bebek terlihat saat Start: gambar + scroll ke canvas
    draw();
    canvas.scrollIntoView({ behavior: 'smooth', block: 'center' });

    overlay.classList.add('show');
    overlay.setAttribute('aria-hidden','false');
    countEl.textContent = '3';

    startBtn.disabled = true;
    pauseBtn.disabled = true;
    resetBtn.disabled = true;

    const steps = ['3','2','1','GO!'];
    let i = 0;
    countdownTimer = setInterval(() => {
      countEl.textContent = steps[i++];
      if (i === steps.length){
        clearInterval(countdownTimer);
        setTimeout(() => {
          overlay.classList.remove('show');
          overlay.setAttribute('aria-hidden','true');
          beginRace();
        }, 450);
      }
    }, 700);
  }
  function beginRace(){
    running = true; paused = false; countingDown = false;
    statusEl.textContent = `Racing… 0.0/${RACE_LIMIT}s`;
    startClock.t0 = performance.now(); startClock.now = startClock.t0;
    pauseBtn.disabled = false;
    resetBtn.disabled = false;
  }

  // History UI
  function msToClock(s){ return (Math.round(s*100)/100).toFixed(2) + 's'; }
  function renderHistory(){
    if (!history.length){
      historyBody.innerHTML = `<p class="small">Belum ada race. Jalankan balapan lalu hasilnya muncul di sini.</p>`;
      return;
    }
    const rows = history.map(rec => {
      const date = new Date(rec.ts).toLocaleString();
      const winnerId = rec.winner;
      const winnerClr = colors[(winnerId-1)%colors.length];

      const detailList = rec.order.map((id, idx) => {
        const clr = colors[(id-1)%colors.length];
        const time = rec.times[id];
        return `
          <span class="chip">
            <span class="dot" style="background:${clr}"></span>
            <b>#${String(idx+1).padStart(2,'0')}</b>
            <span>Duck ${id}</span>
            <span class="small">(${msToClock(time)})</span>
          </span>
        `;
      }).join('');

      return `
        <details>
          <summary>
            <span class="chip">
              <span class="dot" style="background:${winnerClr}"></span>
              Race #${rec.id} — Winner: Duck ${winnerId}
            </span>
            <span class="small"> • ${date}</span>
          </summary>
          <div style="margin-top:8px;display:flex;flex-wrap:wrap">${detailList}</div>
        </details>
      `;
    }).join('');
    historyBody.innerHTML = rows;
  }

  // Events
  startBtn.addEventListener('click', () => {
    if (winner || finishOrder.length) resetRace(); // reset cepat jika habis race
    if (!countingDown && !running) startCountdown();
  });
  pauseBtn.addEventListener('click', () => {
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    statusEl.textContent = paused ? 'Paused.' : `Racing… ${Math.min(raceTime(), RACE_LIMIT).toFixed(1)}/${RACE_LIMIT}s`;
  });
  resetBtn.addEventListener('click', () => {
    if (countdownTimer){ clearInterval(countdownTimer); countdownTimer = null; }
    overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true');
    resetRace();
  });

  historyBtn.addEventListener('click', () => {
    renderHistory();
    historyModal.classList.add('show'); historyModal.setAttribute('aria-hidden','false');
  });
  closeHistoryBtn.addEventListener('click', () => {
    historyModal.classList.remove('show'); historyModal.setAttribute('aria-hidden','true');
  });
  clearHistoryBtn.addEventListener('click', () => {
    if (!confirm('Hapus semua history balapan?')) return;
    history = [];
    localStorage.removeItem('duck_race_history_v1');
    localStorage.removeItem('duck_race_lastIndex');
    raceIndex = 0;
    renderHistory();
  });
  historyModal.addEventListener('click', (e) => {
    if (e.target === historyModal){
      historyModal.classList.remove('show'); historyModal.setAttribute('aria-hidden','true');
    }
  });

  // Boot
  resetRace();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
