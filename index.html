<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Duck River Race</title>
<style>
  :root{
    --river-h: 560px;
    --lanes: 5;
    --lane-h: calc((var(--river-h) - var(--pad) * 2) / var(--lanes));
    --bank-h: 80px;
    --pad: 18px;
    --finish-w: 18px;
    --duck-h: min(44px, calc(var(--lane-h) - 10px));
    --duck-w: calc(var(--duck-h) * 72 / 44);
    --max-race-s: 10; /* hard cap of 10 seconds */
    --sky: #cfe8ff;
    --water-1:#79c7ff;
    --water-2:#5bb8ff;
    --wave:#ffffff40;
    --bank:#8bd17a;
    --bank-edge:#6db15e;
    --rock:#7a6e6a;
    --tree:#2f7a34;
    --trunk:#864f2a;
    --line:#ffffff30;
    --finish-dark:#333;
    --finish-light:#eee;
    --text:#0b1a2a;
    --accent:#0a6efd;
    --card:#ffffffd9;
    --shadow: 0 10px 30px rgba(0,0,0,.18);
  }

  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    color:var(--text);
    background:
      radial-gradient(1200px 600px at 50% -10%, #ffffff 0%, transparent 60%) ,
      linear-gradient(#eaf5ff, #cfe8ff 60%, #c3e1ff);
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:24px;
  }

  .app{
    width:min(1200px, 96vw);
  }

  .card{
    background:var(--card);
    backdrop-filter: blur(6px);
    border-radius:22px;
    box-shadow: var(--shadow);
    padding:18px 18px 24px;
  }

  header{
    display:flex;
    align-items:center;
    gap:14px;
    padding:6px 6px 14px;
  }
  header h1{
    margin:0;
    font-weight:800;
    letter-spacing:.2px;
    font-size: clamp(18px, 2.4vw, 26px);
  }
  header .badge{
    font-size:12px;
    padding:6px 10px;
    border-radius:999px;
    background:#0a6efd14;
    border:1px solid #0a6efd33;
    color:#084298;
    font-weight:600;
  }

  .controls{
    display:flex;
    flex-wrap:wrap;
    align-items:center;
    gap:10px;
    margin-bottom:12px;
  }
  button{
    appearance:none;
    border:none;
    border-radius:12px;
    padding:12px 16px;
    font-weight:700;
    cursor:pointer;
    background:var(--accent);
    color:white;
    box-shadow: 0 6px 16px rgba(10,110,253,.25);
    transition: transform .06s ease, filter .2s ease, opacity .2s ease;
  }
  button:hover{ filter:brightness(1.08) }
  button:active{ transform: translateY(1px) }
  button.secondary{
    background:#11182710;
    color:#0b1a2a;
    border:1px solid #11182720;
    box-shadow:none;
  }
  button:disabled{
    opacity:.55;
    cursor:not-allowed;
    transform:none;
  }
  .status{
    margin-left:auto;
    font-weight:700;
    background:#11182708;
    border:1px solid #11182720;
    color:#0b1a2a;
    padding:10px 12px;
    border-radius:10px;
    min-width:160px;
    text-align:center;
  }

  .stage{
    position:relative;
    width:100%;
    height: calc(var(--river-h) + var(--bank-h) * 2 + 12px);
    overflow:hidden;
    border-radius:18px;
    border:1px solid #ffffff80;
    background: linear-gradient(#e3f4ff, #d9eeff) no-repeat;
  }

  /* Banks (top & bottom) with scenery */
  .bank{
    position:absolute;
    left:0; right:0;
    height:var(--bank-h);
    background:
      radial-gradient(180px 40px at 10% 60%, #ffffff80, transparent 60%),
      linear-gradient(180deg, var(--bank) 0%, var(--bank-edge) 100%);
    z-index:2;
    display:flex;
    align-items:flex-end;
    padding:0 10px 8px;
    gap:12px;
  }
  .bank.top{ top:0; align-items:flex-start; padding:8px 10px 0; }
  .bank .scenery{
    display:flex;
    gap:12px;
    flex-wrap:nowrap;
    width:100%;
    justify-content:space-between;
    opacity:.95;
    filter: drop-shadow(0 2px 0 rgba(0,0,0,.12));
  }
  .tree{
    width:36px; height:46px; position:relative;
    animation: sway 3.5s ease-in-out infinite;
    transform-origin: bottom center;
  }
  .tree .trunk{
    position:absolute; bottom:0; left:50%; transform:translateX(-50%);
    width:8px; height:18px; background:var(--trunk); border-radius:3px;
  }
  .tree .crown{
    position:absolute; bottom:10px; left:50%; transform:translateX(-50%);
    width:34px; height:28px; background:var(--tree); border-radius:50%;
    box-shadow: 0 -10px 0 6px #34903a inset;
  }
  .rock{
    width:32px; height:20px;
    background:var(--rock);
    border-radius: 40% 60% 45% 55% / 65% 60% 40% 50%;
    transform: rotate(-6deg);
    filter: brightness(.95);
    animation: breathe 4s ease-in-out infinite;
  }
  @keyframes sway{
    0%,100%{ transform: rotate(0deg) }
    50%{ transform: rotate(-2deg) }
  }
  @keyframes breathe{
    0%,100%{ transform: translateY(0) rotate(-6deg) }
    50%{ transform: translateY(-1px) rotate(-7deg) }
  }

  /* River */
  .river{
    position:absolute;
    top:var(--bank-h);
    left:0; right:0;
    height:var(--river-h);
    background:
      linear-gradient(180deg, var(--water-1), var(--water-2));
    overflow:hidden;
  }

  /* Subtle water waves & ripples (two moving layers) */
  .river::before,
  .river::after{
    content:"";
    position:absolute; inset:0;
    background-repeat: repeat;
    pointer-events:none;
  }
  /* Wide, slow sine-like stripes */
  .river::before{
    background-image:
      repeating-linear-gradient( to right,
        transparent 0 80px,
        var(--wave) 80px 84px,
        transparent 84px 170px
      );
    animation: drift 9s linear infinite;
  }
  /* Soft circular ripples */
  .river::after{
    background-image:
      radial-gradient(10px 6px at 10% 30%, #ffffff50 0 20%, transparent 21%),
      radial-gradient(8px 5px at 30% 70%, #ffffff45 0 20%, transparent 21%),
      radial-gradient(9px 6px at 55% 40%, #ffffff40 0 20%, transparent 21%),
      radial-gradient(10px 6px at 80% 65%, #ffffff35 0 20%, transparent 21%);
    animation: ripple 6s ease-in-out infinite;
    opacity:.6;
  }
  @keyframes drift{
    from{ background-position: 0 0 }
    to{ background-position: 260px 0 }
  }
  @keyframes ripple{
    0%,100%{ transform: translateX(0) translateY(0) }
    50%{ transform: translateX(-20px) translateY(2px) }
  }

  /* Lanes & finish line */
  .lanes{
    position:absolute; inset:0;
    padding: var(--pad);
  }
  .lane{
    position:relative;
    height: var(--lane-h);
    border-bottom: 1px dashed var(--line);
  }
  .lane:last-child{ border-bottom:none }

  .finish{
    position:absolute;
    top:var(--pad);
    bottom:var(--pad);
    right: calc(var(--pad) + 0px);
    width:var(--finish-w);
    background:
      linear-gradient(90deg, #0000 0 45%, #0002 45% 55%, #0000 55% 100%),
      repeating-linear-gradient(180deg,
        var(--finish-light) 0 12px,
        var(--finish-dark) 12px 24px);
    border-left:1px solid #00000030;
    border-right:1px solid #00000020;
    z-index:4;
    box-shadow: inset 0 0 0 1px #00000010;
  }

  /* Ducks */
  .duck{
    --x: 0px;
    position:absolute;
    left: var(--pad);
    top:0;
    width:var(--duck-w);
    height:var(--duck-h);
    transform: translateX(var(--x));
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:3;
  }
  .duck .wake{
    position:absolute;
    left:-10px; right:6px; top:50%;
    height: 10px;
    transform: translateY(-50%);
    background:
      radial-gradient(10px 5px at right 50%, #ffffff55 0 50%, transparent 55%);
    opacity:.5;
    filter: blur(0.3px);
    animation: wake 0.7s linear infinite;
  }
  @keyframes wake{
    0%{ background-position: 0 0 }
    100%{ background-position: 12px 0 }
  }

  .duck svg{
    width:var(--duck-w);
    height:var(--duck-h);
    overflow:visible;
    animation: bob 1.2s ease-in-out infinite;
  }
  @keyframes bob{
    0%,100%{ transform: translateY(0) }
    50%{ transform: translateY(3px) }
  }

  /* Lane numbers */
  .lane .num{
    position:absolute;
    left:4px; top:6px;
    font-size: 12px;
    font-weight:800;
    color:#083b6b80;
    user-select:none;
  }

  /* Result banner */
  .result{
    margin-top:14px;
    padding:12px 14px;
    border-radius:12px;
    background:#10b98118;
    border:1px solid #10b98155;
    color:#065f46;
    font-weight:700;
    display:none;
  }
  .result.show{ display:block }

  /* Helper: small text */
  .hint{
    font-size:12px;
    color:#0b1a2a99;
    margin-left:6px;
  }

  /* Responsive tweaks */
  @media (max-width: 720px){
    :root{
      --river-h: 520px;
      --bank-h: 70px;
      --duck-w: 64px;
      --duck-h: 40px;
      --pad: 12px;
    }
    .status{ min-width:unset }
  }
</style>
</head>
<body>
  <div class="app card">
    <header>
      <h1>üèÅ Duck River Race</h1>
      <div class="badge">10 ducks ‚Ä¢ 10s max</div>
    </header>

    <div class="controls">
      <button id="startBtn">Start Race</button>
      <button id="resetBtn" class="secondary" disabled>Reset</button>
      <div class="status" id="status">Ready</div>
      <span class="hint">Tip: resize window then press Reset to re-calc distance.</span>
    </div>

    <div class="stage" id="stage">
      <!-- Top bank with scenery -->
      <div class="bank top">
        <div class="scenery">
          <div class="tree"><div class="trunk"></div><div class="crown"></div></div>
          <div class="rock"></div>
          <div class="tree"><div class="trunk"></div><div class="crown"></div></div>
          <div class="rock"></div>
          <div class="tree"><div class="trunk"></div><div class="crown"></div></div>
          <div class="rock"></div>
          <div class="tree"><div class="trunk"></div><div class="crown"></div></div>
        </div>
      </div>

      <!-- River -->
      <div class="river" id="river">
        <div class="lanes" id="lanes"></div>
        <div class="finish" id="finish"></div>
      </div>

      <!-- Bottom bank with scenery -->
      <div class="bank bottom">
        <div class="scenery">
          <div class="rock"></div>
          <div class="tree"><div class="trunk"></div><div class="crown"></div></div>
          <div class="rock"></div>
          <div class="tree"><div class="trunk"></div><div class="crown"></div></div>
          <div class="rock"></div>
          <div class="tree"><div class="trunk"></div><div class="crown"></div></div>
          <div class="rock"></div>
        </div>
      </div>
    </div>

    <div class="result" id="result"></div>
  </div>

<script>
(() => {
  const LANES = 5;
  const MAX_RACE_S = 10;           // hard cap of 10 seconds
  const MIN_FINISH_S = 7.0;        // random winner can finish as early as 7s
  const DUCK_W = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--duck-w')) || 72;

  const lanesEl = document.getElementById('lanes');
  const finishEl = document.getElementById('finish');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const statusEl = document.getElementById('status');
  const resultEl = document.getElementById('result');
  const stageEl = document.getElementById('stage');

  let raceState = 'idle'; // 'idle' | 'running' | 'done'
  let ducks = [];
  let rafId = null;
  let startTime = 0;
  let winner = null;
  let distancePx = 0;

  // Build lanes + ducks
  function buildTrack(){
    lanesEl.innerHTML = '';
    ducks = [];
    for(let i=0;i<LANES;i++){
      const lane = document.createElement('div');
      lane.className = 'lane';
      lane.style.top = `calc(${i} * var(--lane-h))`;
      const num = document.createElement('div');
      num.className = 'num';
      num.textContent = `#${i+1}`;
      lane.appendChild(num);

      const duck = document.createElement('div');
      duck.className = 'duck';
      duck.style.top = `calc(${i} * var(--lane-h) + (var(--lane-h) - var(--duck-h)) / 2)`;
      duck.style.setProperty('--x', '0px');
      duck.innerHTML = `
        <div class="wake"></div>
        ${duckSVG()}
      `;
      lane.appendChild(duck);

      lanesEl.appendChild(lane);
      ducks.push({
        id: i+1,
        el: duck,
        x: 0,
        speed: 0,       // px/s
        finished: false,
        finishTime: null,
      });
    }
    calcDistance();
  }

  function calcDistance(){
    // distance from duck left to finish inner left minus duck width
    const pad = parseFloat(getComputedStyle(lanesEl).paddingLeft) || 12;
    const lanesRect = lanesEl.getBoundingClientRect();
    const finishRect = finishEl.getBoundingClientRect();
    distancePx = (finishRect.left - lanesRect.left) - pad - DUCK_W - 6; // 6px margin from line
  }

  // SVG for the duck (inline, cute yellow duck)
  function duckSVG(){
    return `
    <svg viewBox="0 0 120 60" aria-hidden="true">
      <defs>
        <linearGradient id="b" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0" stop-color="#ffde59"/>
          <stop offset="1" stop-color="#ffc83d"/>
        </linearGradient>
        <linearGradient id="w" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0" stop-color="#ffd94a"/>
          <stop offset="1" stop-color="#ffbd2e"/>
        </linearGradient>
      </defs>
      <!-- subtle wake bubbles -->
      <g opacity="0.16">
        <ellipse cx="12" cy="40" rx="6" ry="3" fill="#fff"/>
        <ellipse cx="20" cy="42" rx="4.5" ry="2.2" fill="#fff"/>
      </g>
      <!-- body -->
      <ellipse cx="56" cy="35" rx="34" ry="18" fill="url(#b)" stroke="#cc9f15" stroke-width="1.2"/>
      <!-- tail -->
      <path d="M26 34 q-10 -4 -12 -10 q10 4 20 1" fill="url(#w)" stroke="#cc9f15" stroke-width="1"/>
      <!-- wing -->
      <path d="M47 30 q-6 6 -5 12 q8 2 18 -2 q-6 -6 -13 -10z" fill="#ffd34a" stroke="#cc9f15" stroke-width="1" opacity=".9"/>
      <!-- head -->
      <circle cx="78" cy="26" r="12" fill="url(#w)" stroke="#cc9f15" stroke-width="1.2"/>
      <!-- eye -->
      <circle cx="81.5" cy="23.5" r="2.2" fill="#1a2332"/>
      <circle cx="80.7" cy="23" r="0.8" fill="#fff"/>
      <!-- beak -->
      <path d="M90 26 q10 2 12 4 q-6 4 -13 1 z" fill="#ff8c3a" stroke="#cc6f1f" stroke-width="1"/>
      <!-- chin shadow -->
      <ellipse cx="76" cy="31.5" rx="6" ry="2" fill="#00000010"/>
    </svg>`;
  }

  function reset(){
    cancelAnimationFrame(rafId);
    winner = null;
    raceState = 'idle';
    statusEl.textContent = 'Ready';
    resultEl.classList.remove('show');
    resultEl.textContent = '';

    // Reset positions
    ducks.forEach(d => {
      d.x = 0;
      d.speed = 0;
      d.finished = false;
      d.finishTime = null;
      d.el.style.setProperty('--x', '0px');
      // re-enable gentle bob animation
      d.el.querySelector('svg').style.animationPlayState = 'running';
    });

    startBtn.disabled = false;
    resetBtn.disabled = true;
  }

  function startRace(){
    if(raceState === 'running') return;
    calcDistance();

    // Assign a target finish time for each duck between MIN_FINISH_S..MAX_RACE_S (random)
    ducks.forEach(d => {
      const tf = rand(MIN_FINISH_S, MAX_RACE_S); // seconds
      d.speed = distancePx / tf;                 // px/s
      d.x = 0;
      d.finished = false;
      d.finishTime = null;
      // small per-duck bob phase offset
      d.el.querySelector('svg').style.animationDelay = `${rand(0,0.8).toFixed(2)}s`;
    });

    // tiny lane-based variability (drafting / wiggle over time)
    startTime = performance.now();
    raceState = 'running';
    startBtn.disabled = true;
    resetBtn.disabled = true;
    statusEl.textContent = 'Racing‚Ä¶ 0.00s';
    resultEl.classList.remove('show');

    // animate
    rafId = requestAnimationFrame(tick);
  }

  function tick(now){
    const elapsed = (now - startTime) / 1000; // seconds
    if (raceState !== 'running') return;

    // Update ducks
    ducks.forEach((d, i) => {
      if(d.finished) return;
      // slight ¬±2% jiggle to speed to feel organic
      const jiggle = 1 + Math.sin((elapsed + i * 0.37) * 2.3) * 0.02;
      d.x = Math.min(distancePx, d.speed * elapsed * jiggle);
      d.el.style.setProperty('--x', `${d.x}px`);

      if(d.x >= distancePx && !d.finished){
        d.finished = true;
        d.finishTime = Math.min(elapsed, MAX_RACE_S);
        if(!winner){
          winner = d;
          endRace('winner');
        }
      }
    });

    // Update status timer
    if(!winner){
      statusEl.textContent = `Racing‚Ä¶ ${elapsed.toFixed(2)}s`;
    }

    // Stop if reached hard limit (10s) with no winner (fallback)
    if(elapsed >= MAX_RACE_S && !winner){
      // pick farthest as winner
      const leader = [...ducks].sort((a,b)=>b.x - a.x)[0];
      leader.finished = true;
      leader.finishTime = MAX_RACE_S;
      winner = leader;
      endRace('timecap');
      return;
    }

    if(raceState === 'running') rafId = requestAnimationFrame(tick);
  }

  function endRace(reason){
    raceState = 'done';
    cancelAnimationFrame(rafId);

    // Pause bobbing on winner, keep others bobbing
    ducks.forEach(d=>{
      const svg = d.el.querySelector('svg');
      svg.style.animationPlayState = (d === winner) ? 'paused' : 'running';
    });

    const timeStr = winner.finishTime.toFixed(2).replace(/\.00$/,'');
    statusEl.textContent = `Winner: Duck #${winner.id} ‚Ä¢ ${timeStr}s`;
    resultEl.classList.add('show');
    resultEl.textContent = `üèÜ Duck #${winner.id} wins in ${timeStr}s ${reason==='timecap' ? '(time cap)' : ''}!`;
    resetBtn.disabled = false;
  }

  function rand(min, max){
    return Math.random() * (max - min) + min;
  }

  // Build once
  buildTrack();

  // Update badge sesuai konstanta
  document.querySelector('.badge').textContent = `${LANES} ducks ‚Ä¢ ${MAX_RACE_S}s max`;

  // Handle controls
  startBtn.addEventListener('click', startRace);
  resetBtn.addEventListener('click', reset);

  // Recalculate on resize (keep positions sane)
  let resizeTimer;
  window.addEventListener('resize', ()=>{
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=>{
      if(raceState !== 'running'){
        calcDistance();
        // snap duck x back within new distance
        ducks.forEach(d=>{
          d.x = Math.min(d.x, distancePx);
          d.el.style.setProperty('--x', `${d.x}px`);
        });
      }
    }, 120);
  });
})();
</script>
</body>
</html>
